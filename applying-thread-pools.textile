h2. Implicit couplings between tasks and execution policies

Executor framework decouples task submission from task execution. But there are many tasks that require specific execution policies:
* *Dependent tasks* create constraints on the execution policy that must be carefully managed to avoid liveness problems.
* *Tasks that exploit thread confinement and work in single-threaded executors*. Single-threaded pools make stronger promises about concurency. They guarantee tasks are not executed concurrently, which allows to relax thread safety. Objects can be confined to the thread and accessed without syncrhonization. This forms an implicit coupling between the task and execution policy.
* *Response-time-sensitive tasks*. GUI applications are sensitive to response time. Implicit coupling is the restriction not to submit long running tasks or many tasks to executor.
* *Tasks using ThreadLocal*--threads can be reused between tasks. Hence *ThreadLocal* can be used in thread pools only when lifetime of an object is restricted to a single task. Should not be used in pool threads to communicate between threads.

Thread pools work best when tasks are homogeneous and independent
* mixing long-running and short-running tasks risks clogging the pool
* submitting tasks that depend on each other risks deadlock

Some tasks require or preclude a specific execution policy
* tasks that depend on other tasks require that the thread pool be large enough that tasks are never queued or rejected
* tasks that exploit thread confinement require serial execution

h4. Thread starfvation deadlock

If tasks that depend on other tasks execute in a thread pool, they can deadlock
* in a single-threaded executor a task that submits another task to the same executor and waits for its result always deadlocks
* same thing can happen in larger pools if all threads are executing tasks that are blocked waiting for other tasks still on the work queue

In addition to any explicit bounds on the size of a thread pool, there may also be implicit limits because of constraints on other resource. If all tasks need a JDBC connection and there are only 10 available then it is as if thread pool had size of 10.

h4. Long running tasks

Even if deadlock is not a possibility thread pool can be clogged with long-running tasks, increasing service time for short tasks. The responsiveness may suffer.
* use timed versions of methods
* tune the size of the pool

h2. Sizing thread pools

Common rules:
* Sizes should be provided by a configuration mechanism or computed dynamically by consulting *Runtime.getRuntime().availableProcessors*.
* If a thread pool size is too big, threads compete for scarce CPU and memory resources.
* If a thread pool size is too small, throughput suffers as processors go unused despite available work.
* Understand your computing environment (how many processors? memory?)
* Understand the nature of your tasks (mostly computation, IO, or both?), do they need a scarce resource (JDBC connection)? Different categories of tasks with differents behaviours consider using multiple threads where each can be configured accordingly to its workload.

How to compute thread pool size:
* For compute-intensive tasks, an Ncpu processor achieves optimum utilization with a thread pool of *Nthreads = Ncpu+1* threads (even compute-intensive threads ocasionally take a page fault or pause for some other reason, and extra runnable thread prevents CPU cycles from going unused)
* For IO intensive or any other blocking tasks: *Nthreads = Ncpu * Ucpu / C*, where *C in [0; 1]* is the ratio of computing time, *Ucpu in [0; 1]* is the desired load.
* *Ncpu = Runtime.getRuntime().availableProcessors()*
* Other resources can contribute to sizing constraints are memory, file handles, socket handles, database connections. Calculate how much each task requires, divide total amount available by that number. This will an upper bound on the pool size.

h2. Configuring *ThreadPoolExecutor*

