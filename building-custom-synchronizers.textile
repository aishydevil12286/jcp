State-dependent classes have operations with state-based preconditions (*FutureTask*, *BlockingQueue*)

Implement new snchronizers using
* intrinsic *condition queue mechanism*
* explicit *Condition* objects
* *AbstractQueuedSynchronizer* framework

h2. Managing state dependence

In a single-threaded program if a precondition is not met it will never become true, therefore, they can be coded to fail if preconditions are not met.
In a concurrent program, such conditions may change because of other thread's actions, and state-dependent methods can wait for preconditions to become true.

The built-in *condition queue mechanism* enables threads
* to block until an object has entered a state that allows progress
* to wake blocked threads when they may be able to make further progress

Alternative (worst) approaches
* throwing exceptions/returning error --- moves burden of retrying on the client, unables ordering
 * sleeping --- can oversleep
 * spin wait --- consumes many CPU cycles
 * *Thread.yield* --- platform-dependent, still possible to oversleep or consume too much CPU
* Crude blocking by polling and sleeping
 * complex implementation
 * have to choose between responsiveness and CPU consumption (timeout)
 * have to deal with *InterruptedException*

A *condition queue* gives a wait set (a group of threads) a way to wait for a specific condition to become true. Elements of *contidion* queues are threads.
Each object can act as a queue
* *wait*, *notify*, *notifyAll* methods
* should be called holding the lock on the object (preserving state consistency: need to wait on the condition (reading) and to change the condition (writing))
* *wait* atomically releases the lock, reacquires upon waking

Advantages:
* CPU efficiency
* context-switch overhead
* responsiveness
 
h2. Using condition queues

h4. The condition predicate

The condition predicate is the precondition that makes an operation state dependent.

Condition predicate
* involves state variables guarded by a lock
* before testing the condition predicate we must acquire that lock
* that lock object must be the condition queue object

If the precondition is not true *wait* releases the lock, puts thread in a waiting queue, reactuires the lock after some of the following events occured:
* thread is interrupted
* timeout has passed
* thread is notified
* spurious wakeup

h4. Waking up too soon

When a thread is waked up and reacquired the lock, the condition may not be true:
* other waiting or unrelated threads may have already modified the state
* other threads may wait for another predicate and that notification may not be related to your precondition

The rules
* always check the precondition again
* check the precondition in a loop

h2. Explicit Condition objects

h2. Anatomy of a synchronizer

h2. AbstractQueueSynchronizer

h2. AQS in java.util.concurrent. synchronizer classes