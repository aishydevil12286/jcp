h2. Building blocks (delegating thread safety to existing thread safe classes)

h3. Synchronized collections

Source of magic - *Collections.synchronizedXxx* factory methods Encapsulates the state of collection and sycnrhonizes all methods accessing state.

Problems of synchronized collections
 * Returned iterators use modification count 1) are fail-fast, throw ConcurrentModificationException 2) no sync for counts, may see stale data
 * That's the reason you May need
  ** Additional client-side locking to guard compound actions (iteration, navigation, conditional operations)
   *** Client side locking for compound actions may hurt performance
   *** Client side locking for compound actions may lead to high contention and hurt scalability
   *** Client side locking _acting_ on elements may lead to deadlock (_acting_ may lock on smth else)
  ** Copying (may require syncrhonization as well), has own performance penalty
 * Also, there are hidden iterators

h3. Concurrent collections

Replacing synchronized collections with concurrent offers dramatic scalability improvements with little risk.
Examples:
* ConcurrentHashMap, CopyOnWriteArrayList
* BlockingQueue, ConcurrentLinkedQueue, PriorityQueue
* ConcurrentSkipListMap, ConcurrentSkipListSet

h4. ConcurrentHashMap

Uses a finer-grained locking mechanism called lock striping to allow a greater degree of shared access.
* many readers can acceess list concurrently
* readers may access map concurrently with writers
* a limited number of threads can access map concurrently
* some atomic operation: putIfAbsent, removeIfEqual, replaceIfEqual
* Iterators are weakly consistent:
 ** tolerates concurrent modification
 ** traverses elements as they existed when the iterator was constructed
 ** (not guaranteed) reflects modification to the collection after the construction of iterator

Disadvantages:
* size() may return an approximation instead of an exact count - weakened semantics to improve performance for the most important operations: get, put, containsKey, remove
* not possible to lock the whole collection for an atomic operation (possible for synchronized collections) (reasonable tradeoff)

h4. CopyOnWriteArraylist

What is it
* Derives thread safety from the fact that properly constructed and safely published effectively immutable object is thread safe (reading operations)
* Mutability is implemented by creating and republishing a new copy.

Eliminates doing anything to safely iterate collection
* the need to copy collection
* the need to synchronize

h3. Blocking queues, producer-consumer pattern

h3. Blocking and interruptible methods

h3. Synchronizers