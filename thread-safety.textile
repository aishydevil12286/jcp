h2. Thread safety

A class is thread safe if it **behaves correctly when accessed from multiple threads**, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.

h2. State issues

h3. So what's the problem?

Informally, *an object's state* is its data, stored in state variables such as instance or static fields. An object's state may include fields from other, dependent objects; HashMap's state is partially stored in the HashMap object itself, but also in many Map.Entry objects. An object's state encompasses any data hat can affect its externally visible behavior.

* Atomicity
 ** Race conditions
 ** Read-modify-write
 ** Check-then-act
 ** Compound actions
Operations *A and B are atomic* with respect to each other if, from the perspective of a thread executing A, when another thread executes B,either all of B has executed or none of it has. An *atomic operation* is one that is atomic with respect to all operations, including itself, that operate on the same state.
* Visibility
 ** reordering
 ** stale data
 ** non-atomic
 ** 64-bit operations
 ** escape
    
h3. Where is the problem then?

| *State vs Sharing* | Not shared | Shared |
| Stateless | Yes | Yes |
| Immutable | Yes | Yes |
| Mutable | Yes | *No* |

An object is *immutable* if:
* Its state cannot be modified after construction
* All its fields are final
* It is properly constructed

An object is *properly constructed* means that the this reference does not escape during construction.

h3. How to solve the problem?

* Don't share
    * literally
    * confinement: thread, stack, ad-hoc
* Make stateless
* Make immutable (no atomicity and visibility problems, consider correct immutability definition)
* Effectively immutable and published safely (no atomicity problem, but visibility problem)
* Protect mutable shared state
    locks, synchronized block, synchronized method
volatile

Effectively immutable objects need to be safely published in order to be safely used by any thread without synchronization.
*Effectively immutable objects* are those not technically immutable, but whose state will not be modified after publication.

An object is *published safely* if both the reference to the object and the object's state are made visible to other threads at the same time. A properly constructed object can be safely published by:
* initializing an object reference from a static initializer
* storing a reference to it into a volatile field or AtomicReference
* storing a reference to it into a final field of a properly constructed object
* storing a reference to it into a field that is properly guarded by a lock