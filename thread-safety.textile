h3. Thread safety

A class is thread safe if it **behaves correctly when accessed from multiple threads**, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.

h3. Where is the problem?

Informally, *an object's state* is its data, stored in state variables such as instance or static fields. An object's state may include fields from other, dependent objects; HashMap's state is partially stored in the HashMap object itself, but also in many Map.Entry objects. An object's state encompasses any data hat can affect its externally visible behavior.

* Atomicity
Operations *A and B are atomic* with respect to each other if, from the perspective of a thread executing A, when another thread executes B,either all of B has executed or none of it has. An *atomic operation* is one that is atomic with respect to all operations, including itself, that operate on the same state.
Race conditions:
 ** Read-modify-write
 ** Check-then-act
 ** Compound actions
 ** Non-atomic 64-bit operations
* Visibility
 ** Stale data (like "read_uncommited", caches?)
 ** Reordering
 ** Non-atomic 64-bit operations
 
h3. Where is the problem?

Is an object thread safe?

| *State vs Sharing* | Not shared | Shared |
| Stateless | Yes | Yes |
| Immutable | Yes | Yes |
| Mutable | Yes | *No* |


h3. What should I do?
* Make stateless
* Stop sharing, any of:
 ** Not sharing at all
 ** Use confinement, any of:
  *** Thread
  *** Stack
  *** Ad-hoc
* Make immutable, all of (definition of immutability):
 ** state can't be modified after construction
 ** all fields are final
 ** *properly constructed*
* If mutable
 ** If read-only (aka *effectively immutable*) -- make it safely published
 ** Otherwise if writes and reads are going to be made from separate threads, all of:
  *** *Safely published*
  *** *Protect mutable state*
   **** Every shared, mutable variable should be guarded by lock
   **** For every invariant that involves more than one variable, all the variables involved in that invariant must be guarded by the same lock
   **** Performance and liveness aspects should be considered when implementing
    ***** There is a tension between performance and simplicity
    ***** Consider it, but resist to prematurely sacrifice simplicity for the sake of performance
    ***** Avoid holding locks during long computations or operations such as IO

Avoding the *state escape*:
* **Properly constructing** -- an object is *properly constructed* if _this_ reference does not escape during construction. Examples:
 ** _this_ reference explicitly escapes -- used to register instance as a listener
 ** _this_ reference implicitly escapes -- inner class instance using _this_ class methods is passed
* *Publishing safely*: both the reference to the object and the object's state are made visible to other threads at the same time. A properly constructed object can be safely published by:
 ** initializing an object reference from a static initializer
 ** storing a reference to it into a volatile field or AtomicReference
 ** storing a reference to it into a final field of a properly constructed object
 ** storing a reference to it into a field that is properly guarded by a lock

h3. Not covered yet
* volatile
* final in immutable
* properly constructed immutable, safely published effectively immutable, safey published and protected mutable