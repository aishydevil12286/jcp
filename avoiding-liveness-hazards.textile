* There is a tension between safety and liveness. Locking is used to ensure safety, but indiscriminate use of locking can cause lock-ordering deadlocks.
* Thread pools and semaphores are used to bound resource consumption, but failure to understand activities being bounded can cause resource deadlocks.

Java applications do not recover from deadlocks, so it's worthwhile to ensure that your design precludes the conditions that could cause it.

h2. Deadlock

When thread A holds lock L and tries to ackquire lock M, but at the same time thread B holds M and tries to acquire L, both threads will wait forever. If nodes in a directed graph are threads and endges represent "waiting" relation, then a cyclic graph indicates there is a deadlock.

Database systems are designed to recover from deadlocks. A transaction may acquire many locks until it commits, and two transactions may deadlock. When a database detects deadlock (analysing directed graph), it picks a victim and aborts the transaction. The application can then retry the aborted transaction, which may be able to repeat the transaction.

The JVM is not helpful in resolving deadlocks. When a set of Java threads deadlock, they threads are permanently out of comission. The application may stall completely, a particular subsystem may stall, or performance may suffer.

h4. Lock-ordering deadlocks

*leftRight* method acquires *left* and *right* locks. *rightLeft* methods acquires *right* and *left* locks.

If the *leftRight* methods acquired the *left* lock and then the *rightLeft* acquired *right* lock, they will deadlock.

The deadlock came about because the two threads attempted to acquire the same lock in a different order. A program will be free of lock-ordering deadlocks if all threads acquire the locks in a fixed global order.

h4. Dynamic lock order deadlocks

Locks used may depend on variables values, same method locking on 2 arguments may lead to deadlock when called in two different threads.

* One way to induce an ordering is to use *System.identityHashCode*, which returns the value that would be returned by *Object.hashCode*.
** If two objects have identical hashes, a third "tie breaking" lock is used. By acquiring the tie-breaking lock before acquiring locks, we ensure that only one thread at a time performs the risky task of acquiring two locks in arbitary order, elimitaring the possibility of deadlock.
** If hash collisions were common, this technique might become a concurrency bottleneck (== having a single, program-wide lock). Hash collisions with System.identityHashCode are vanishingly infrequent.
* If objects for synchronization has a unique, comparable key, inducing a lock order is even easier: order objects by their key.

h4. Deadlocks between cooperating objects.

No method may explicitly acquire two locks but deadlock may still be possible. Cooperating objects may invoke each other's synchronized methods in a way that leads to monitor locks taken in a wrong order.

In general, invoking an alien method with a lock held is asking for liveness trouble. The alien method might acquire other locks (risking deadlock) or block for unexpectedly long time, stalling other threads that need the lock you hold.

h4. Open calls

Calling a method with no locks held is called an open call
* Classes that rely on open calls are more well-behaved and composable
* The liveness analysis of a program that reles exclusively on open calls is far easier than that of one that does not. Makes it easier to identify the code paths that acquire multiple locks and therefore to ensure that locks are acquired in a constant order

Restructuring a synchronized block to allow open calls can have undesireable consequences, since it takes an operation that was atomic and makes it nonatomic.
* In many cases, the loss of atomicity is perfectly acceptable
* In some cases, the loss of atomicity is a problem, and you will have to use another technique to achieve atomicity. One such technique is to restructure the code around open call so that only one thread can execute that code path. For example, hold the lock to mark the service as shutting down, release the lock (other threads waiting because of status set), make an open call, wait for resources release, mark service as shut down, let other threads access it.

h4. Resource deadlocks

Tasks can deadlock waiting for resources as they can deadlock waiting for locks.

* Thread A could hold a connection to database D1 and wait for a connection to D2, thread B could hold a connection to database D2 and wait for a connection to D1.
* Thread-starvation deadlock: a task executing in a single threaded executor submits another task to it and waits for its completion.

h2. Avoiding and diagnosing deadlocks

h2. Other liveness hazards